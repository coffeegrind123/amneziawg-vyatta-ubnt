name: Release

on:
  workflow_run:
    workflows: ["Build kernel module and tools"]
    types: [completed]
    branches: [master]
  push:
    tags:
      - '*'
  workflow_dispatch: # Allow manual triggering for testing

env:
  MODULE_VERSION: "1.0.20241112"
  TOOLS_VERSION: "1.0.20250706"
  PACKAGE_RELEASE: "1"
  FIRMWARE_ER_v1: "v1.10.11"
  FIRMWARE_ER_v2: "v2.0.9"
  FIRMWARE_UGW: "4.4.50"

jobs:
  create_release:
    # Only run if:
    # - workflow_run completed successfully, OR
    # - manual tag push (but not the v1 tag), OR  
    # - manual workflow_dispatch
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'push' && github.ref != 'refs/tags/v1') ||
      github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    name: Create Release

    steps:
      - uses: actions/checkout@v4
      
      - name: Determine release context
        id: context
        run: |
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            # Auto-release from successful build
            TAG="v${{ env.MODULE_VERSION }}-${{ env.TOOLS_VERSION }}"
            RUN_ID="${{ github.event.workflow_run.id }}"
            RELEASE_TYPE="auto"
            echo "Auto-release triggered by successful build"
          elif [ "${{ github.event_name }}" == "push" ]; then
            # Manual tag-based release
            TAG="${{ github.ref_name }}"
            RUN_ID="" # Will need to find latest successful run
            RELEASE_TYPE="manual"
            echo "Manual release triggered by tag: $TAG"
          else
            # Manual workflow dispatch
            TAG="v${{ env.MODULE_VERSION }}-${{ env.TOOLS_VERSION }}"
            RUN_ID="" # Will need to find latest successful run
            RELEASE_TYPE="dispatch"
            echo "Manual release triggered by workflow dispatch"
          fi
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          
      - name: Find latest successful build (for manual releases)
        id: find_build
        if: steps.context.outputs.run_id == ''
        run: |
          echo "Finding latest successful build from master branch..."
          
          # Use GitHub CLI to get the latest successful workflow run
          RUN_ID=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/workflows/build.yml/runs?branch=master&status=success&per_page=1" \
            --jq '.workflow_runs[0].id')
          
          if [ "$RUN_ID" == "null" ] || [ -z "$RUN_ID" ]; then
            echo "âŒ No successful build found!"
            exit 1
          fi
          
          echo "âœ… Found successful build: $RUN_ID"
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Create release directory
        run: mkdir -p release-assets
        
      - name: Download release artifacts
        run: |
          RUN_ID="${{ steps.context.outputs.run_id || steps.find_build.outputs.run_id }}"
          echo "Downloading artifacts from build run: $RUN_ID"
          
          # List all artifacts from the build run
          echo "Available artifacts:"
          gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts" \
            --jq '.artifacts[] | select(.name | startswith("release-")) | .name'
          
          # Download all release artifacts using GitHub CLI
          gh run download $RUN_ID \
            --pattern "release-*" \
            --dir release-assets/
          
          echo "âœ… Downloaded artifacts to release-assets/"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Organize artifacts
        run: |
          echo "=== ORGANIZING RELEASE ARTIFACTS ==="
          
          # The download creates subdirectories for each artifact
          # Move all files to the root of release-assets
          find release-assets -mindepth 2 -type f \( -name "*.deb" -o -name "*.tar.gz" \) -exec mv {} release-assets/ \;
          
          # Remove empty subdirectories
          find release-assets -mindepth 1 -type d -empty -delete
          
          echo "Final artifact structure:"
          find release-assets -type f | sort
          
      - name: Validate release assets
        run: |
          echo "=== RELEASE ASSETS VALIDATION ==="
          
          # List all release files
          echo "All release files:"
          find release-assets -type f \( -name "*.deb" -o -name "*.tar.gz" \) | sort
          
          # Count files by type
          DEB_COUNT=$(find release-assets -name "*.deb" | wc -l)
          TAR_COUNT=$(find release-assets -name "*.tar.gz" | wc -l) 
          TOTAL_COUNT=$((DEB_COUNT + TAR_COUNT))
          
          echo ""
          echo "ðŸ“Š Summary:"
          echo "  â€¢ EdgeOS .deb packages: $DEB_COUNT"
          echo "  â€¢ UnifiOS .tar.gz packages: $TAR_COUNT"
          echo "  â€¢ Total release assets: $TOTAL_COUNT"
          
          # Validate we have the expected number of artifacts
          if [ $TOTAL_COUNT -eq 0 ]; then
            echo "âŒ ERROR: No release assets found!"
            echo "Available files in release-assets:"
            ls -la release-assets/ || echo "Directory is empty"
            exit 1
          fi
          
          if [ $DEB_COUNT -eq 0 ] && [ $TAR_COUNT -eq 0 ]; then
            echo "âŒ ERROR: No .deb or .tar.gz files found!"
            exit 1
          fi
          
          echo "âœ… Release assets validation passed"
          
      - name: Create or update tag (for auto-releases)
        if: steps.context.outputs.release_type == 'auto'
        run: |
          TAG="${{ steps.context.outputs.tag }}"
          echo "Creating release tag: $TAG"
          
          # Check if tag already exists
          if git tag -l | grep -q "^$TAG$"; then
            echo "Tag $TAG already exists, deleting it first"
            git tag -d $TAG || true
            git push --delete origin $TAG || true
          fi
          
          # Create and push new tag
          git tag $TAG
          git push origin $TAG
          
          echo "âœ… Created and pushed tag: $TAG"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Generate release body
        run: |
          TAG="${{ steps.context.outputs.tag }}"
          RELEASE_TYPE="${{ steps.context.outputs.release_type }}"
          
          # Create release body
          cat > RELEASE_BODY.md << 'EOF'
          **Changelog**
          - Updated AmneziaWG kernel module to ${{ env.MODULE_VERSION }}
          - Updated AmneziaWG tools to ${{ env.TOOLS_VERSION }}
          
          ## Versions
          
          | Component | Version |
          |-----------|---------|
          | AmneziaWG Module | ${{ env.MODULE_VERSION }} |
          | AmneziaWG Tools | ${{ env.TOOLS_VERSION }} |
          | EdgeOS v1 | ${{ env.FIRMWARE_ER_v1 }} |
          | EdgeOS v2 | ${{ env.FIRMWARE_ER_v2 }} |
          | USG firmware | ${{ env.FIRMWARE_UGW }} |
          
          ---
          
          ## ðŸ“¦ Installation Packages
          
          **IMPORTANT:** EdgeOS devices have different packages for different firmware versions:
          - **v1** packages: For EdgeOS ${{ env.FIRMWARE_ER_v1 }}
          - **v2** packages: For EdgeOS ${{ env.FIRMWARE_ER_v2 }}
          
          âš ï¸ **Make sure to download the correct version for your firmware!** The installer will error if you use the wrong version.
          
          ## ðŸ”§ Device Mapping
          
          | Package Name | Compatible Devices |
          |--------------|-------------------|
          | **e50** | EdgeRouter X, EdgeRouter X SFP |
          | **e100** | EdgeRouter Lite, EdgeRouter PoE |
          | **e200** | EdgeRouter 8, EdgeRouter Pro |
          | **e300** | EdgeRouter 4, EdgeRouter 6P, EdgeRouter 12 |
          | **e1000** | EdgeRouter Infinity |
          | **ugw3** | UniFi Security Gateway |
          | **ugw4** | UniFi Security Gateway Pro 4 |
          | **ugwxg** | UniFi Security Gateway XG 8 |
          | **UnifiOS** | UDM, UDM-Pro, UDM-SE, UDR, UXG-Pro |
          EOF
          
          echo "Generated release body for tag: $TAG"
          
      - name: Create GitHub Release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ steps.context.outputs.tag }}
          name: "AmneziaWG ${{ env.MODULE_VERSION }}"
          bodyFile: RELEASE_BODY.md
          artifacts: "release-assets/*"
          draft: false
          prerelease: false
          allowUpdates: true
          makeLatest: true
          generateReleaseNotes: false
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Release summary
        run: |
          TAG="${{ steps.context.outputs.tag }}"
          RELEASE_TYPE="${{ steps.context.outputs.release_type }}"
          ASSET_COUNT=$(find release-assets -type f \( -name "*.deb" -o -name "*.tar.gz" \) | wc -l)
          
          echo "ðŸŽ‰ === RELEASE CREATED SUCCESSFULLY === ðŸŽ‰"
          echo ""
          echo "ðŸ“‹ Release Details:"
          echo "  â€¢ Tag: $TAG" 
          echo "  â€¢ Name: AmneziaWG ${{ env.MODULE_VERSION }}"
          echo "  â€¢ Type: $RELEASE_TYPE release"
          echo "  â€¢ Assets: $ASSET_COUNT files"
          echo ""
          echo "ðŸ”— Release URL:"
          echo "https://github.com/${{ github.repository }}/releases/tag/$TAG"
          echo ""
          echo "ðŸ“¦ Assets uploaded:"
          find release-assets -type f \( -name "*.deb" -o -name "*.tar.gz" \) | sort | sed 's/release-assets\//  â€¢ /'
          echo ""
          if [ "$RELEASE_TYPE" == "auto" ]; then
            echo "âœ¨ This release was automatically created from successful build!"
          fi
